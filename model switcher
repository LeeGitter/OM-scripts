local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local MODEL_ID = 81925598549837
local OMTmodel = nil
local currentAnimation = nil
local lastGroundState = true
local lastYPosition = 0
local animator = nil
local heartbeatConnection = nil

local STATE_ANIMATIONS = {
    default = {
        Idle = {id = "rbxassetid://75739082381837", track = nil, shouldLoop = true},
        Walk = {id = "rbxassetid://83638241246562", track = nil, shouldLoop = true},
        Run = {id = "rbxassetid://111832051535988", track = nil, shouldLoop = true, speed = 2},
        Jump = {id = "rbxassetid://131035860836096", track = nil, shouldLoop = false},
        Fall = {id = "rbxassetid://129887519880329", track = nil, shouldLoop = true},
        Roll = {id = "rbxassetid://125272843113306", track = nil, shouldLoop = false},
        Hitted = {id = "rbxassetid://88993215908744", track = nil, shouldLoop = false}
    },
    downed = {
        Idle = {id = "rbxassetid://74087570581803", track = nil, shouldLoop = true},
        Walk = {id = "rbxassetid://110239503461838", track = nil, shouldLoop = true}
    }
}

local function setupAnimations()
    if not animator then return end
    
    for stateName, stateTable in pairs(STATE_ANIMATIONS) do
        for animName, animData in pairs(stateTable) do
            if animData.track then
                animData.track:Stop()
                animData.track = nil
            end
        end
    end
    
    for stateName, stateTable in pairs(STATE_ANIMATIONS) do
        for animName, animData in pairs(stateTable) do
            local animation = Instance.new("Animation")
            animation.AnimationId = animData.id
            animData.track = animator:LoadAnimation(animation)
            animData.track.Looped = animData.shouldLoop
            if animData.speed then
                animData.track:AdjustSpeed(animData.speed)
            end
        end
    end
end

local function playAnimation(animName, stateName)
    if not animator then return end
    if currentAnimation == animName then return end
    
    local state = stateName or "default"
    local stateAnimations = STATE_ANIMATIONS[state]
    
    if not stateAnimations then return end
    
    if currentAnimation and stateAnimations[currentAnimation] and stateAnimations[currentAnimation].track and stateAnimations[currentAnimation].track.IsPlaying then
        stateAnimations[currentAnimation].track:Stop()
    end
    
    if stateAnimations[animName] and stateAnimations[animName].track then
        stateAnimations[animName].track:Play()
        if animName == "Run" and stateAnimations.Run.speed then
            stateAnimations.Run.track:AdjustSpeed(stateAnimations.Run.speed)
        end
        currentAnimation = animName
    end
end

local function checkJumpAndFall()
    if not humanoid or not humanoidRootPart then return end
    
    local currentY = humanoidRootPart.Position.Y
    local humanoidState = humanoid:GetState()
    
    if humanoidState == Enum.HumanoidStateType.Jumping then
        playAnimation("Jump")
        lastYPosition = currentY
        lastGroundState = false
        return
    end
    
    local isFalling = humanoidState == Enum.HumanoidStateType.Freefall
    local isOnGround = humanoidState == Enum.HumanoidStateType.Running
    
    if isFalling and (lastYPosition - currentY) > 0.1 then
        playAnimation("Fall")
    end
    
    if not lastGroundState and isOnGround then
        playAnimation("Idle")
    end
    
    lastGroundState = isOnGround
    lastYPosition = currentY
end

local function updateMovementAnimations()
    if not humanoid then return end
    
    if currentAnimation == "Jump" or currentAnimation == "Fall" then
        return
    end
    
    local moving = humanoid.MoveDirection.Magnitude > 0.1
    local targetAnimation = "Idle"
    
    if moving then
        targetAnimation = humanoid.WalkSpeed < 12 and "Walk" or "Run"
    end
    
    if currentAnimation ~= targetAnimation then
        playAnimation(targetAnimation)
    end
end

local function handleHitted()
    playAnimation("Hitted")
end

local function loadModel()
    if shadowModel then
        shadowModel:Destroy()
        shadowModel = nil
    end

    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end

    local success, model = pcall(function()
        return game:GetObjects("rbxassetid://"..MODEL_ID)[1]
    end)

    if not success or not model then
        return
    end

    shadowModel = model:Clone()
    shadowModel.Name = "ShadowModel"
    shadowModel.Parent = workspace

    for _, part in ipairs(shadowModel:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Anchored = false
            part.CanCollide = false
            part.CanTouch = false
            part.Massless = true
        end
    end

    local modelHumanoid = shadowModel:FindFirstChildOfClass("Humanoid")
    if modelHumanoid then
        modelHumanoid.HipHeight = 6.8
        animator = modelHumanoid:FindFirstChildOfClass("Animator")
        if animator then
            setupAnimations()
        end
    end

    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Transparency = 1
        elseif part:IsA("Accessory") then
            part.Handle.Transparency = 1
        end
    end

    heartbeatConnection = RunService.Heartbeat:Connect(function(dt)
        if not shadowModel or not humanoidRootPart then
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
                heartbeatConnection = nil
            end
            return
        end
        
        local root = shadowModel:FindFirstChild("HumanoidRootPart") or shadowModel.PrimaryPart
        if root then
            root.CFrame = humanoidRootPart.CFrame
        end
        
        checkJumpAndFall()
        updateMovementAnimations()
    end)
end

local function init()
    if player.Character then
        loadModel()
    end

    player.CharacterAdded:Connect(function(char)
        character = char
        humanoid = char:WaitForChild("Humanoid")
        humanoidRootPart = char:WaitForChild("HumanoidRootPart")
        task.wait(1)
        loadModel()
    end)
    
    spawn(function()
        local success, remoteFunction = pcall(function()
            return game:GetService("Players"):WaitForChild(player.Name):WaitForChild("PlayerGui"):WaitForChild("Round"):WaitForChild("Game"):WaitForChild("RemoteFunction")
        end)
        
        if success and remoteFunction then
            local oldInvoke = remoteFunction.InvokeServer
            remoteFunction.InvokeServer = function(self, ...)
                local args = {...}
                if args[1] == 0 then
                    handleHitted()
                end
                return oldInvoke(self, ...)
            end
        end
    end)
end

init()

return {
    handleHitted = handleHitted
}
