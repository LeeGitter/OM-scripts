local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local MODEL_ID = 83570032909483
local shadowModel = nil
local currentAnimation = nil
local lastGroundState = true
local lastYPosition = 0
local animator = nil
local heartbeatConnection = nil

--========================================================
--  YOUR ANIMSAVE OBJECTVALUE CONTAINER
--========================================================
local animsave = game:GetService("ReplicatedStorage"):WaitForChild("animsave")

--========================================================
--  ANIMATION TABLE (file = ObjectValue name)
--========================================================
local STATE_ANIMATIONS = {
    default = {
        Idle  = {file = "Idle",  track = nil, shouldLoop = true},
        Walk  = {file = "Walk",  track = nil, shouldLoop = true},
        Run   = {file = "Run",   track = nil, shouldLoop = true, speed = 2},
        Jump  = {file = "Jump",  track = nil, shouldLoop = false},
        Fall  = {file = "Fall",  track = nil, shouldLoop = true},
        Roll  = {file = "Roll",  track = nil, shouldLoop = false},
        Hitted = {file = "Hitted", track = nil, shouldLoop = false}
    },

    downed = {
        Idle = {file = "Idle_Downed", track = nil, shouldLoop = true},
        Walk = {file = "Walk_Downed", track = nil, shouldLoop = true}
    }
}

--========================================================
--  LOAD KEYFRAMESEQUENCE FROM OBJECTVALUE
--========================================================
local function loadTrackFromFile(animName, animData)
    if not animator then return end

    local obj = animsave:FindFirstChild(animData.file)
    if not obj or not obj:IsA("ObjectValue") or not obj.Value then
        warn("Missing ObjectValue animation:", animData.file)
        return
    end

    local seq = obj.Value
    if not seq:IsA("KeyframeSequence") then
        warn("Invalid KeyframeSequence for:", animData.file)
        return
    end

    local anim = Instance.new("Animation")
    anim.AnimationId = "" -- local sequence
    anim.Parent = character

    local track = animator:LoadAnimation(anim)
    track.Looped = animData.shouldLoop

    if animData.speed then
        track:AdjustSpeed(animData.speed)
    end

    animData.track = track
end

--========================================================
--  SETUP ALL ANIMATIONS
--========================================================
local function setupAnimations()
    if not animator then return end

    for _, stateTable in pairs(STATE_ANIMATIONS) do
        for _, animData in pairs(stateTable) do
            if animData.track then
                animData.track:Stop()
                animData.track = nil
            end
        end
    end

    for _, stateTable in pairs(STATE_ANIMATIONS) do
        for animName, animData in pairs(stateTable) do
            loadTrackFromFile(animName, animData)
        end
    end
end

--========================================================
--  PLAY ANIMATION
--========================================================
local function playAnimation(animName, stateName)
    if not animator then return end
    if currentAnimation == animName then return end

    local state = stateName or "default"
    local stateAnimations = STATE_ANIMATIONS[state]
    if not stateAnimations then return end

    if currentAnimation and stateAnimations[currentAnimation] then
        local oldTrack = stateAnimations[currentAnimation].track
        if oldTrack and oldTrack.IsPlaying then
            oldTrack:Stop()
        end
    end

    local animData = stateAnimations[animName]
    if animData and animData.track then
        animData.track:Play()
        currentAnimation = animName
    end
end

--========================================================
--  MOVEMENT + JUMP/FALL LOGIC
--========================================================
local function checkJumpAndFall()
    if not humanoid or not humanoidRootPart then return end

    local currentY = humanoidRootPart.Position.Y
    local humanoidState = humanoid:GetState()

    if humanoidState == Enum.HumanoidStateType.Jumping then
        playAnimation("Jump")
        lastYPosition = currentY
        lastGroundState = false
        return
    end

    local isFalling = humanoidState == Enum.HumanoidStateType.Freefall
    local isOnGround = humanoidState == Enum.HumanoidStateType.Running

    if isFalling and (lastYPosition - currentY) > 0.1 then
        playAnimation("Fall")
    end

    if not lastGroundState and isOnGround then
        playAnimation("Idle")
    end

    lastGroundState = isOnGround
    lastYPosition = currentY
end

local function updateMovementAnimations()
    if not humanoid then return end

    if currentAnimation == "Jump" or currentAnimation == "Fall" then
        return
    end

    local moving = humanoid.MoveDirection.Magnitude > 0.1
    local target = "Idle"

    if moving then
        target = humanoid.WalkSpeed < 12 and "Walk" or "Run"
    end

    if currentAnimation ~= target then
        playAnimation(target)
    end
end

local function handleHitted()
    playAnimation("Hitted")
end

--========================================================
--  LOAD MODEL + ANIMATIONS
--========================================================
local function loadModel()
    if shadowModel then
        shadowModel:Destroy()
        shadowModel = nil
    end

    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end

    local ok, model = pcall(function()
        return game:GetObjects("rbxassetid://"..MODEL_ID)[1]
    end)

    if not ok or not model then return end

    shadowModel = model:Clone()
    shadowModel.Name = "ShadowModel"
    shadowModel.Parent = workspace

    for _, part in ipairs(shadowModel:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Anchored = false
            part.CanCollide = false
            part.CanTouch = false
            part.Massless = true
        end
    end

    local modelHumanoid = shadowModel:FindFirstChildOfClass("Humanoid")
    if modelHumanoid then
        modelHumanoid.HipHeight = 6.8
        animator = modelHumanoid:FindFirstChildOfClass("Animator")
        if animator then
            setupAnimations()
        end
    end

    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Transparency = 1
        elseif part:IsA("Accessory") then
            part.Handle.Transparency = 1
        end
    end

    heartbeatConnection = RunService.Heartbeat:Connect(function()
        if not shadowModel or not humanoidRootPart then
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
                heartbeatConnection = nil
            end
            return
        end

        local root = shadowModel:FindFirstChild("HumanoidRootPart") or shadowModel.PrimaryPart
        if root then
            root.CFrame = humanoidRootPart.CFrame
        end

        checkJumpAndFall()
        updateMovementAnimations()
    end)
end

--========================================================
--  INIT
--========================================================
local function init()
    if player.Character then
        loadModel()
    end

    player.CharacterAdded:Connect(function(char)
        character = char
        humanoid = char:WaitForChild("Humanoid")
        humanoidRootPart = char:WaitForChild("HumanoidRootPart")
        task.wait(1)
        loadModel()
    end)

    spawn(function()
        local ok, remoteFunction = pcall(function()
            return player:WaitForChild("PlayerGui"):WaitForChild("Round"):WaitForChild("Game"):WaitForChild("RemoteFunction")
        end)

        if ok and remoteFunction then
            local oldInvoke = remoteFunction.InvokeServer
            remoteFunction.InvokeServer = function(self, ...)
                local args = {...}
                if args[1] == 0 then
                    handleHitted()
                end
                return oldInvoke(self, ...)
            end
        end
    end)
end

init()

return {
    handleHitted = handleHitted
}
