local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

local flymetertext = true
local flyMax = 45
local flyMeter = flyMax
local flySpeedMax = 25
local specialFlySpeed = 140
local flyAccel = 70
local flyDecel = 80
local flyDrainMax = 4
local flyDrainIdle = 10.9 / 20.4
local flyDrainSpeed = 20
local flyDrainMinSpeed = 100
local flyBarTween = nil
local flyBarShowTime = 0.3
local flyBarHideTime = 0.4
local jumpInputActive = false
local jumpInputStart = 0
local jumpHoldThreshold = 0.3
local flyRegenCooldown = false
local flyRegenCooldownTime = 3

local flyGui = Instance.new("BillboardGui")
flyGui.Name = "FlyMeterGui"
flyGui.ResetOnSpawn = false
flyGui.Adornee = humanoidRootPart

if isMobile then
    flyGui.Size = UDim2.new(0, 24, 0, 88)
else
    flyGui.Size = UDim2.new(0, 60, 0, 220)
end

flyGui.SizeOffset = Vector2.new(0,0)
flyGui.StudsOffset = Vector3.new(-4, 0, 0)
flyGui.AlwaysOnTop = true
flyGui.MaxDistance = 60
flyGui.Parent = character

local flyBarFrame = Instance.new("Frame")

if isMobile then
    flyBarFrame.Size = UDim2.new(0, 8, 0, 88)
    flyBarFrame.Position = UDim2.new(0, 0, 0.5, -44)
else
    flyBarFrame.Size = UDim2.new(0, 24, 0, 220)
    flyBarFrame.Position = UDim2.new(0, 0, 0.5, -110)
end

flyBarFrame.BackgroundTransparency = 1
flyBarFrame.AnchorPoint = Vector2.new(0, 0.5)
flyBarFrame.Parent = flyGui

local flyBarBG = Instance.new("Frame")
flyBarBG.Size = UDim2.new(1, 0, 1, 0)
flyBarBG.Position = UDim2.new(0, 0, 0, 0)
flyBarBG.BackgroundColor3 = Color3.fromRGB(30, 30, 60)
flyBarBG.BorderSizePixel = 0
flyBarBG.BackgroundTransparency = 0.5
flyBarBG.Parent = flyBarFrame

local flyBar = Instance.new("Frame")
flyBar.Size = UDim2.new(1, 0, 1, 0)
flyBar.Position = UDim2.new(0, 0, 1, 0)
flyBar.BackgroundColor3 = Color3.fromRGB(0, 120, 255)
flyBar.BorderSizePixel = 0
flyBar.BackgroundTransparency = 0.1
flyBar.Parent = flyBarFrame

local flyBarText = Instance.new("TextLabel")
flyBarText.Size = UDim2.new(1, 0, 0, 16)
flyBarText.Position = UDim2.new(0, 0, 1, 4)
flyBarText.BackgroundTransparency = 1
flyBarText.TextColor3 = Color3.fromRGB(180, 220, 255)
flyBarText.Font = Enum.Font.GothamBold
flyBarText.TextScaled = true
flyBarText.Text = ""
flyBarText.Parent = flyBarFrame

flyBarFrame.Visible = false

local function setFlyBarVisible(visible)
    if flyBarTween then flyBarTween:Cancel() end
    if visible then
        flyBarFrame.Visible = true
        flyBarTween = TweenService:Create(flyBarFrame, TweenInfo.new(flyBarShowTime, Enum.EasingStyle.Quad), {BackgroundTransparency = 0})
        flyBarTween:Play()
    else
        flyBarTween = TweenService:Create(flyBarFrame, TweenInfo.new(flyBarHideTime, Enum.EasingStyle.Quad), {BackgroundTransparency = 1})
        flyBarTween:Play()
        task.delay(flyBarHideTime, function()
            flyBarFrame.Visible = false
        end)
    end
end

local function updateFlyBar()
    local percent = math.clamp(flyMeter / flyMax, 0, 1)
    flyBar.Size = UDim2.new(1, 0, percent, 0)
    flyBar.Position = UDim2.new(0, 0, 1 - percent, 0)

    if flymetertext then
        flyBarText.Text = string.format("%.1f / %d", flyMeter, flyMax)
    else
        flyBarText.Text = ""
    end
end

local flying = false
local flyConn = nil
local bv = nil
local bg = nil
local flyInertiaDecel = 6

local function flyStart()
    if flying or flyMeter <= 0 then return end

    flying = true
    setFlyBarVisible(true)
    flySpeed = humanoidRootPart.Velocity.Magnitude

    bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e5,1e5,1e5)
    bv.Velocity = humanoidRootPart.Velocity
    bv.Parent = humanoidRootPart

    bg = Instance.new("BodyGyro")
    bg.MaxTorque = Vector3.new(1e5,1e5,1e5)
    bg.P = 1e4
    bg.D = 500
    bg.CFrame = humanoidRootPart.CFrame
    bg.Parent = humanoidRootPart

    flyConn = RunService.RenderStepped:Connect(function(dt)
        if not flying then
            if flyConn then flyConn:Disconnect() flyConn = nil end
            if bv then bv:Destroy() bv = nil end
            if bg then bg:Destroy() bg = nil end
            setFlyBarVisible(false)
            return
        end

        local cam = workspace.CurrentCamera
        local move = Vector3.new()

        if UserInputService:IsKeyDown(Enum.KeyCode.W) then move = move + cam.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then move = move - cam.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then move = move - cam.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then move = move + cam.CFrame.RightVector end

        if move.Magnitude > 0 then move = move.Unit end

        local moving = move.Magnitude > 0

        if moving then
            flySpeed = math.min(flySpeed + flyAccel * dt, flySpeedMax)
            bv.Velocity = move * flySpeed
            bg.CFrame = CFrame.lookAt(Vector3.new(), cam.CFrame.LookVector * Vector3.new(1,0,1) + Vector3.new(0, move.Y, 0))
        else
            flySpeed = math.max(flySpeed - flyDecel * dt, 0)
            bv.Velocity = bv.Velocity:Lerp(Vector3.new(), math.clamp(flyInertiaDecel * dt, 0, 1))
        end

        local drain = 0
        if flySpeed >= flyDrainMinSpeed then
            drain = flyDrainSpeed * dt
        else
            drain = flyDrainIdle * dt
        end

        flyMeter = math.max(flyMeter - drain, 0)
        updateFlyBar()

        if flyMeter <= 0 then
            flying = false
            if not flyRegenCooldown then
                flyRegenCooldown = true
                task.delay(flyRegenCooldownTime, function()
                    flyRegenCooldown = false
                end)
            end
        end
    end)
end

local function flyCancel()
    if flying then
        flying = false
        setFlyBarVisible(false)
        if flyConn then flyConn:Disconnect() flyConn = nil end
        if bv then bv:Destroy() bv = nil end
        if bg then bg:Destroy() bg = nil end
        humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    end
end

local function rechargeFlyMeter()
    task.spawn(function()
        while true do
            if not flying and flyMeter < flyMax and not flyRegenCooldown then
                flyMeter = math.min(flyMeter + flyDrainIdle * 6, flyMax)
                updateFlyBar()
            end
            task.wait(0.5)
        end
    end)
end

rechargeFlyMeter()

local function onJumpInputBegan(input, gameProcessed)
    if gameProcessed then return end
    if not isMobile and input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space then
        if not jumpInputActive then
            jumpInputActive = true
            jumpInputStart = tick()
        end
    end
end

local function onJumpInputEnded(input, gameProcessed)
    if gameProcessed then return end
    if not isMobile and input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space then
        if jumpInputActive then
            jumpInputActive = false
            if flying then
                flyCancel()
            end
        end
    end
end

UserInputService.InputBegan:Connect(onJumpInputBegan)
UserInputService.InputEnded:Connect(onJumpInputEnded)

task.spawn(function()
    while true do
        if not isMobile then
            if jumpInputActive and not flying and flyMeter > 0 then
                local heldTime = tick() - jumpInputStart
                if heldTime >= jumpHoldThreshold then
                    flyStart()
                end
            end
            if not jumpInputActive and flying then
                flyCancel()
            end
        end
        task.wait(0.05)
    end
end)

updateFlyBar()
