local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

local flymetertext = true

-- CHANGED: stamina capacity
local flyMax = 75
local flyMeter = flyMax

-- CHANGED: speed reduced to 1/3
local flySpeedMax = 75
local specialFlySpeed = 140 -- untouched
local flyAccel = 10
local flyDecel = 20

local flyDrainMax = 4

-- CHANGED: stamina usage halved
local flyDrainIdle = 15
local flyDrainSpeed = 20

local flyDrainMinSpeed = 25
local flyBarTween = nil
local flyBarShowTime = 0.3
local flyBarHideTime = 0.4
local jumpInputActive = false
local jumpInputStart = 0
local jumpHoldThreshold = 0.3
local flyRegenCooldown = false
local flyRegenCooldownTime = 15

local flyGui = Instance.new("BillboardGui")
flyGui.Name = "FlyMeterGui"
flyGui.ResetOnSpawn = false
flyGui.Adornee = humanoidRootPart

if isMobile then
    flyGui.Size = UDim2.new(0, 24, 0, 88)
else
    flyGui.Size = UDim2.new(0, 60, 0, 220)
end

flyGui.SizeOffset = Vector2.new(0,0)
flyGui.StudsOffset = Vector3.new(-4, 0, 0)
flyGui.AlwaysOnTop = true
flyGui.MaxDistance = 60
flyGui.Parent = character

local flyBarFrame = Instance.new("Frame")

if isMobile then
    flyBarFrame.Size = UDim2.new(0, 8, 0, 88)
    flyBarFrame.Position = UDim2.new(0, 0, 0.5, -44)
else
    flyBarFrame.Size = UDim2.new(0, 24, 0, 220)
    flyBarFrame.Position = UDim2.new(0, 0, 0.5, -110)
end

flyBarFrame.BackgroundTransparency = 1
flyBarFrame.AnchorPoint = Vector2.new(0, 0.5)
flyBarFrame.Parent = flyGui

local flyBarBG = Instance.new("Frame")
flyBarBG.Size = UDim2.new(1, 0, 1, 0)
flyBarBG.Position = UDim2.new(0, 0, 0, 0)
flyBarBG.BackgroundColor3 = Color3.fromRGB(30, 30, 60)
flyBarBG.BorderSizePixel = 0
flyBarBG.BackgroundTransparency = 0.5
flyBarBG.Parent = flyBarFrame

local flyBar = Instance.new("Frame")
flyBar.Size = UDim2.new(1, 0, 1, 0)
flyBar.Position = UDim2.new(0, 0, 1, 0)

-- CHANGED: color to #F2C354
flyBar.BackgroundColor3 = Color3.fromRGB(242, 195, 84)

flyBar.BorderSizePixel = 0
flyBar.BackgroundTransparency = 0.1
flyBar.Parent = flyBarFrame

local flyBarText = Instance.new("TextLabel")
flyBarText.Size = UDim2.new(1, 0, 0, 16)
flyBarText.Position = UDim2.new(0, 0, 1, 4)
flyBarText.BackgroundTransparency = 1
flyBarText.TextColor3 = Color3.fromRGB(180, 220, 255)
flyBarText.Font = Enum.Font.GothamBold
flyBarText.TextScaled = true
flyBarText.Text = ""
flyBarText.Parent = flyBarFrame

flyBarFrame.Visible = false

local function setFlyBarVisible(visible)
    if flyBarTween then flyBarTween:Cancel() end
    if visible then
        flyBarFrame.Visible = true
        flyBarTween = TweenService:Create(flyBarFrame, TweenInfo.new(flyBarShowTime, Enum.EasingStyle.Quad), {BackgroundTransparency = 0})
        flyBarTween:Play()
    else
        flyBarTween = TweenService:Create(flyBarFrame, TweenInfo.new(flyBarHideTime, Enum.EasingStyle.Quad), {BackgroundTransparency = 1})
        flyBarTween:Play()
        task.delay(flyBarHideTime, function()
            flyBarFrame.Visible = false
        end)
    end
end

local function updateFlyBar()
    local percent = math.clamp(flyMeter / flyMax, 0, 1)
    flyBar.Size = UDim2.new(1, 0, percent, 0)
    flyBar.Position = UDim2.new(0, 0, 1 - percent, 0)

    if flymetertext then
        flyBarText.Text = string.format("%.1f / %d", flyMeter, flyMax)
    else
        flyBarText.Text = ""
    end
end

local flying = false
local flyConn = nil
local bv = nil
local bg = nil
local flyInertiaDecel = 6

-- ANIMATIONS ADDED
local animFlyIdle = Instance.new("Animation")
animFlyIdle.AnimationId = "rbxassetid://89515158858178"

local animFlyMove = Instance.new("Animation")
animFlyMove.AnimationId = "rbxassetid://134795550846208"

local trackIdle = humanoid:LoadAnimation(animFlyIdle)
local trackMove = humanoid:LoadAnimation(animFlyMove)

local function playFlyAnim(moving)
    if moving then
        trackIdle:Stop()
        if not trackMove.IsPlaying then trackMove:Play() end
    else
        trackMove:Stop()
        if not trackIdle.IsPlaying then trackIdle:Play() end
    end
end

local function flyStart()
    if flying or flyMeter <= 0 then return end

    flying = true
    setFlyBarVisible(true)
    flySpeed = humanoidRootPart.Velocity.Magnitude

    bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e5,1e5,1e5)
    bv.Velocity = humanoidRootPart.Velocity
    bv.Parent = humanoidRootPart

    bg = Instance.new("BodyGyro")
    bg.MaxTorque = Vector3.new(1e5,1e5,1e5)
    bg.P = 1e4
    bg.D = 500
    bg.CFrame = humanoidRootPart.CFrame
    bg.Parent = humanoidRootPart

    flyConn = RunService.RenderStepped:Connect(function(dt)
        if not flying then
            if flyConn then flyConn:Disconnect() flyConn = nil end
            if bv then bv:Destroy() bv = nil end
            if bg then bg:Destroy() bg = nil end
            setFlyBarVisible(false)
            return
        end

        local cam = workspace.CurrentCamera
        local move = Vector3.new()

        if UserInputService:IsKeyDown(Enum.KeyCode.W) then move = move + cam.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then move = move - cam.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then move = move - cam.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then move = move + cam.CFrame.RightVector end

        if move.Magnitude > 0 then move = move.Unit end

        local moving = move.Magnitude > 0
        playFlyAnim(moving)

        if moving then
            flySpeed = math.min(flySpeed + flyAccel * dt, flySpeedMax)
            bv.Velocity = move * flySpeed
            bg.CFrame = CFrame.lookAt(humanoidRootPart.Position, humanoidRootPart.Position + cam.CFrame.LookVector)
        else
            flySpeed = math.max(flySpeed - flyDecel * dt, 0)
            bv.Velocity = bv.Velocity:Lerp(Vector3.new(), math.clamp(flyInertiaDecel * dt, 0, 1))
        end

        local drain = (flySpeed >= flyDrainMinSpeed) and (flyDrainSpeed * dt) or (flyDrainIdle * dt)
        flyMeter = math.max(flyMeter - drain, 0)
        updateFlyBar()

        if flyMeter <= 0 then
            flying = false
            flyRegenCooldown = true
            task.delay(flyRegenCooldownTime, function()
                flyRegenCooldown = false
            end)
        end
    end)
end

local function flyCancel()
    if flying then
        flying = false
        setFlyBarVisible(false)
        if flyConn then flyConn:Disconnect() flyConn = nil end
        if bv then bv:Destroy() bv = nil end
        if bg then bg:Destroy() bg = nil end
        humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)

        -- stop animations
        trackIdle:Stop()
        trackMove:Stop()
    end
end

local function rechargeFlyMeter()
    task.spawn(function()
        while true do
            if not flying and flyMeter < flyMax and not flyRegenCooldown then
                flyMeter = math.min(flyMeter + flyDrainIdle * 0.2, flyMax)
                updateFlyBar()
            end
            task.wait(0.5)
        end
    end)
end

rechargeFlyMeter()

local function onJumpInputBegan(input, gameProcessed)
    if gameProcessed then return end
    if not isMobile and input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space then
        if not jumpInputActive then
            jumpInputActive = true
            jumpInputStart = tick()
        end
    end
end

local function onJumpInputEnded(input, gameProcessed)
    if gameProcessed then return end
    if not isMobile and input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space then
        if jumpInputActive then
            jumpInputActive = false
            if flying then
                flyCancel()
            end
        end
    end
end

UserInputService.InputBegan:Connect(onJumpInputBegan)
UserInputService.InputEnded:Connect(onJumpInputEnded)

task.spawn(function()
    while true do
        if not isMobile then
            if jumpInputActive and not flying and flyMeter > 0 then
                local heldTime = tick() - jumpInputStart
                if heldTime >= jumpHoldThreshold then
                    flyStart()
                end
            end
            if not jumpInputActive and flying then
                flyCancel()
            end
        end
        task.wait(0.05)
    end
end)

updateFlyBar()
